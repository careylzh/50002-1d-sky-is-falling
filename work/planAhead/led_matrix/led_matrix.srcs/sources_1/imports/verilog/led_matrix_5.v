/*
   This file was generated automatically by Alchitry Labs version 1.1.6.
   Do not edit this file directly. Instead edit the original Lucid source.
   This is a temporary file and any changes made to it will be destroyed.
*/

module led_matrix_5 (
    input clk,
    input rst,
    input wr_en,
    input [10:0] wr_addr,
    input [2:0] wr_data,
    output reg [1:0] out_r,
    output reg [1:0] out_g,
    output reg [1:0] out_b,
    output reg [3:0] out_addr,
    output reg out_clk,
    output reg out_blk,
    output reg out_lat
  );
  
  
  
  reg [9:0] rd_addr_top;
  
  reg [9:0] rd_addr_bottom;
  
  reg wr_en_top;
  
  reg wr_en_bottom;
  
  reg [9:0] wr_addr_top;
  
  reg [9:0] wr_addr_bottom;
  
  reg [2:0] wr_data_top;
  
  reg [2:0] wr_data_bottom;
  
  reg [5:0] M_shift_reg_clk_d, M_shift_reg_clk_q = 1'h0;
  reg [4:0] M_data_tx_clk_d, M_data_tx_clk_q = 1'h0;
  reg [9:0] M_register_input_counter_d, M_register_input_counter_q = 1'h0;
  reg [3:0] M_refresh_row_counter_d, M_refresh_row_counter_q = 1'h0;
  reg [0:0] M_zero_d, M_zero_q = 1'h0;
  wire [3-1:0] M_matrix_vram_top_out_bit;
  vram_11 matrix_vram_top (
    .clk(clk),
    .rst(rst),
    .read_addr(rd_addr_top),
    .write_en(wr_en_top),
    .write_addr(wr_addr_top),
    .write_data(wr_data_top),
    .out_bit(M_matrix_vram_top_out_bit)
  );
  wire [3-1:0] M_matrix_vram_bottom_out_bit;
  vram_11 matrix_vram_bottom (
    .clk(clk),
    .rst(rst),
    .read_addr(rd_addr_bottom),
    .write_en(wr_en_bottom),
    .write_addr(wr_addr_bottom),
    .write_data(wr_data_bottom),
    .out_bit(M_matrix_vram_bottom_out_bit)
  );
  
  localparam ARRAY = 16'h5555;
  
  localparam ARRAY2 = 64'h0000000000000001;
  
  localparam ARRAY3 = 64'h8000000000000000;
  
  localparam ROW_DATA = 384'h249249249249492492492492db6db6db6db6ffffffffffff249249249249492492492492db6db6db6db6ffffffffffff;
  
  reg [5:0] led_data;
  
  always @* begin
    M_zero_d = M_zero_q;
    M_refresh_row_counter_d = M_refresh_row_counter_q;
    M_register_input_counter_d = M_register_input_counter_q;
    M_shift_reg_clk_d = M_shift_reg_clk_q;
    M_data_tx_clk_d = M_data_tx_clk_q;
    
    out_clk = M_shift_reg_clk_q[5+0-:1] && M_register_input_counter_q < 8'h81;
    M_shift_reg_clk_d = M_shift_reg_clk_q + 1'h1;
    M_data_tx_clk_d = M_data_tx_clk_q + 1'h1;
    if (wr_addr < 11'h400) begin
      wr_en_top = wr_en;
      wr_en_bottom = 1'h0;
      wr_addr_top = wr_addr[0+9-:10];
      wr_addr_bottom = 1'h0;
      wr_data_top = wr_data;
      wr_data_bottom = 1'h0;
    end else begin
      wr_en_top = 1'h0;
      wr_en_bottom = wr_en;
      wr_addr_top = 1'h0;
      wr_addr_bottom = wr_addr - 11'h400;
      wr_data_top = 1'h0;
      wr_data_bottom = wr_data;
    end
    if (M_data_tx_clk_q == 5'h1f) begin
      M_register_input_counter_d = M_register_input_counter_q + 1'h1;
    end
    if (1'h1 <= M_register_input_counter_q && M_register_input_counter_q < 8'h81) begin
      out_addr = M_refresh_row_counter_q;
      out_blk = 1'h1;
      out_lat = 1'h0;
      if (M_zero_q == 1'h0) begin
        rd_addr_top = (M_refresh_row_counter_q * 7'h40) + (M_register_input_counter_q - 1'h1) / 2'h2;
        rd_addr_bottom = (M_refresh_row_counter_q * 7'h40) + (M_register_input_counter_q - 1'h1) / 2'h2;
        M_zero_d = 1'h1;
      end else begin
        rd_addr_top = (M_refresh_row_counter_q * 7'h40) + (M_register_input_counter_q - 2'h2) / 2'h2;
        rd_addr_bottom = (M_refresh_row_counter_q * 7'h40) + (M_register_input_counter_q - 2'h2) / 2'h2;
        M_zero_d = 1'h0;
      end
      out_r[0+0-:1] = M_matrix_vram_top_out_bit[2+0-:1];
      out_g[0+0-:1] = M_matrix_vram_top_out_bit[1+0-:1];
      out_b[0+0-:1] = M_matrix_vram_top_out_bit[0+0-:1];
      out_r[1+0-:1] = M_matrix_vram_bottom_out_bit[2+0-:1];
      out_g[1+0-:1] = M_matrix_vram_bottom_out_bit[1+0-:1];
      out_b[1+0-:1] = M_matrix_vram_bottom_out_bit[0+0-:1];
      if (M_register_input_counter_q == 8'h80) begin
        out_lat = 1'h1;
        if (M_data_tx_clk_q == 4'hf) begin
          M_refresh_row_counter_d = M_refresh_row_counter_q + 1'h1;
        end
      end
    end else begin
      out_blk = 1'h0;
      out_lat = 1'h0;
      out_addr = M_refresh_row_counter_q;
      out_r = 2'h0;
      out_g = 2'h0;
      out_b = 2'h0;
    end
  end
  
  always @(posedge clk) begin
    if (rst == 1'b1) begin
      M_shift_reg_clk_q <= 1'h0;
      M_data_tx_clk_q <= 1'h0;
      M_register_input_counter_q <= 1'h0;
      M_refresh_row_counter_q <= 1'h0;
      M_zero_q <= 1'h0;
    end else begin
      M_shift_reg_clk_q <= M_shift_reg_clk_d;
      M_data_tx_clk_q <= M_data_tx_clk_d;
      M_register_input_counter_q <= M_register_input_counter_d;
      M_refresh_row_counter_q <= M_refresh_row_counter_d;
      M_zero_q <= M_zero_d;
    end
  end
  
endmodule
