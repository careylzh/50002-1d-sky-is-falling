module matrix_ram #(
    ADDRESS_SIZE = 5 : ADDRESS_SIZE > 0, //width of the address field (ABCD signals for matrix_led)
    MATRIX_WIDTH = 64 : MATRIX_WIDTH > 0, //number of LEDs per row in the matrix
    SPRITE_SIZE = 5 : SPRITE_SIZE > 0 
  )(
    input clk,  // clock
    input rst,  // reset
    input generateSky[5],
    input genSky,
    input shiftSky,
    input shiftchickenright,
    input shiftchickenleft,
    input init_chicken_en,
    input start_fromfsm,
    
    input change_chicken,

    input chicken_location[5],

    output gameover,
    output chickenbuild,
    input startbutton,
    
    output restart_tofsm,
    
    

    input row_address[ADDRESS_SIZE],
    input column_address[$clog2(MATRIX_WIDTH)],
    
    output out[6], //6b b1g1r1b0g1r0
    
    output debug[2]
  ) {
  
  const RAMSIZE = $pow(2,ADDRESS_SIZE) * MATRIX_WIDTH;
  
  const SPRITE =         {{3b000,3b000,3b001,3b000, 3b000}, 
                          {3b000,3b111,3b111,3b111, 3b000}, 
                          {3b111,3b100,3b111,3b100, 3b111}, 
                          {3b111,3b111,3b111,3b111, 3b111}, 
                          {3b000,3b111,3b111,3b111, 3b000}};    
  .clk(clk){
    
    
    simple_ram background_ram(#SIZE(3), #DEPTH(RAMSIZE));
    simple_ram chicken_ram(#SIZE(3), #DEPTH(RAMSIZE));
    
    .rst(rst){
      
      fsm state = {PREP,
        START, 
        GENGRASSFIRSTROW,
        GENGRASSSECONDROW,
        GENCHICKENSTARTTOP,
        GEN1CHICKEN,
        GEN2CHICKEN,
        GEN3CHICKEN,
        GEN4CHICKEN,
        GEN5CHICKEN,
        LOOP,
        GENERATESKYBEGIN,
        GENERATESKY1,
        GENERATESKY2,
        SHIFT,
        SHIFTDOWNADDRESS, 
        SHIFTDOWNREADWRITE, 
        CHICKENRIGHTREADWRITE, 
        SHIFTRIGHTCHICKENBEGIN, 
        SHIFTLEFTCHICKENBEGIN,
        ERASECHICKEN1TOP, 
        ERASECHICKEN2TOP, 
        ERASECHICKEN3TOP, 
        ERASECHICKEN4TOP, 
        ERASECHICKEN5TOP, 
        SHIFTRIGHTMID, 
        ERASECHICKEN1TOPLEFT, 
        ERASECHICKEN2TOPLEFT, 
        ERASECHICKEN3TOPLEFT, 
        ERASECHICKEN4TOPLEFT, 
        ERASECHICKEN5TOPLEFT, 
        SHIFTLEFTMID,
        GENCHICKENMID,
        CHECKCOLSTART,
        CHECKCOLREAD,
        CHECKCOL1TOP,
        CHICKENWIN,
        SKYWIN,
        CLEARRAM};
      
      
      dff debug_reg[2];

      dff check_column_address[$clog2(RAMSIZE)];
      dff column_counter[ADDRESS_SIZE];
      
      dff grass_address[$clog2(RAMSIZE)];
      dff grass_counter[ADDRESS_SIZE];
      
      dff sky_counter[ADDRESS_SIZE];
      dff sky_address[$clog2(RAMSIZE)];
      dff current_sky_column[ADDRESS_SIZE];
      
      dff chicken_address[$clog2(RAMSIZE)];
      dff current_chicken_column[ADDRESS_SIZE]; //where the chicken is
      
      dff chicken_counter[ADDRESS_SIZE];
      
      dff shift_address[$clog2(RAMSIZE)];
      dff row_counter[$clog2(MATRIX_WIDTH)+1];
      
      dff clearReg[$clog2(RAMSIZE)];
      
      dff restart;
      dff fromstart[4];
      
      
      dff shiftChickenWhich;
    
      
      
    }
    
  }

  
  sig bgexist;
  sig chickexist;
  
  always{
    

    background_ram.address = 0;
    background_ram.write_data = 0;
    background_ram.write_en = 0;

    
    
    chicken_ram.address = 0;
    chicken_ram.write_data = 0;
    chicken_ram.write_en = 0;



    debug = debug_reg.q;
    gameover = 0 ;//gameover_Stats.q;
    chickenbuild =0;
    
    
    out = 0;
    
    restart_tofsm = restart.q;

    
    case(state.q){

          
         
      state.PREP: //WAIT FOR RESET REGISTER 
        fromstart.d = fromstart.q + 1;
        if (fromstart.q == b1111){
           fromstart.d = b1111;
           state.d = state.START; 
        }
        
     
      state.START:   
        if(restart.q){
          current_chicken_column.d = 0;
          state.d = state.GENGRASSFIRSTROW;
        }
        
        if (startbutton){
          current_chicken_column.d = 0;
          state.d = state.GENGRASSFIRSTROW;
        }

      
      state.GENGRASSFIRSTROW:
        // draw grass at the bottom two rows, loop in this state until all grass are drawn
        background_ram.address = grass_address.q;
        background_ram.write_en = b1;
        background_ram.write_data = b010;
        
        grass_address.d = grass_address.q + MATRIX_WIDTH;
        grass_counter.d = grass_counter.q + 1;
        if (grass_counter.q > 30){
          grass_counter.d = 0;
          state.d = state.GENGRASSSECONDROW;
        }
      
      state.GENGRASSSECONDROW:
        // draw grass at the bottom two rows, loop in this state until all grass are drawn
        background_ram.address = grass_address.q + 1;
        background_ram.write_en = b1;
        background_ram.write_data = b010;
        
        
        grass_address.d = grass_address.q + MATRIX_WIDTH;
        grass_counter.d = grass_counter.q + 1;
        if (grass_counter.q > 30){
          grass_counter.d = 0;
          
          if(fromstart.q == b1111){
            fromstart.d = 0;
            chicken_address.d = MATRIX_WIDTH * (current_chicken_column.q ) + 2;
            state.d = state.GEN1CHICKEN;
          }
          else if (restart.q){
            restart.d = 0;
            chicken_address.d = MATRIX_WIDTH * (current_chicken_column.q ) + 2;
            state.d = state.GEN1CHICKEN;
            
            
          }
          else 
          {
            state.d = state.CHECKCOLSTART;
          }
          
        }

      
      state.SHIFTDOWNADDRESS:
        
        //give address
        if(row_counter.q < 63){ //as long as we haven't reached the last row 
          background_ram.address = shift_address.q+1; // get the next address' data
          row_counter.d = row_counter.q + 1;
          state.d = state.SHIFTDOWNREADWRITE;
        }
        else{
          if (shift_address.q < (RAMSIZE-1)){ // clear the topmost row
            shift_address.d = shift_address.q+1; //if shift address was at 63, this is 64
            row_counter.d = 0;
            background_ram.address = shift_address.q; //write to address 63, clear it, loop back
            background_ram.write_en = b1;
            background_ram.write_data = b000;

            state.d = state.SHIFTDOWNADDRESS;
          }
          else{
            shift_address.d = 0;
            row_counter.d = 0;
            background_ram.address = shift_address.q;
            background_ram.write_en = b1;
            background_ram.write_data = b000;
            
            background_ram.address = shift_address.q;
            background_ram.write_en = b1;
            background_ram.write_data = b000;
            state.d = state.GENGRASSFIRSTROW;
            
          }
          
        }
      
        
        
      state.SHIFTDOWNREADWRITE:
        background_ram.address = shift_address.q; //write it to current address
        background_ram.write_en = b1;
        background_ram.write_data = background_ram.read_data;
        
        shift_address.d = shift_address.q + 1; //increase address by 1
        
        state.d = state.SHIFTDOWNADDRESS;
      
      

      state.SHIFTLEFTCHICKENBEGIN:

        chicken_address.d = MATRIX_WIDTH * (current_chicken_column.q) + 2;
        state.d = state.ERASECHICKEN1TOPLEFT;
      
      state.ERASECHICKEN1TOPLEFT:

        chicken_ram.address = chicken_address.q;
        chicken_ram.write_en = b1;
        chicken_ram.write_data = b000;
        
        chicken_address.d = chicken_address.q + MATRIX_WIDTH; //go to the next row
        chicken_counter.d = chicken_counter.q + 1;
        
        if (chicken_counter.q > 3){ //after 2 pixels erased
          chicken_counter.d = 0;

          chicken_address.d =  MATRIX_WIDTH * current_chicken_column.q + 3;

          state.d = state.ERASECHICKEN2TOPLEFT;
        }
      
      state.ERASECHICKEN2TOPLEFT:


        chicken_ram.address = chicken_address.q;
        chicken_ram.write_en = b1;
        chicken_ram.write_data = b000;
        
        chicken_address.d = chicken_address.q + MATRIX_WIDTH; //go to the next row
        chicken_counter.d = chicken_counter.q + 1;

        if (chicken_counter.q > 3){ //after 4 pixel skies generated
          chicken_counter.d = 0;
                    chicken_address.d =  MATRIX_WIDTH * current_chicken_column.q + 4;
          state.d = state.ERASECHICKEN3TOPLEFT;
        }
      
     state.ERASECHICKEN3TOPLEFT:
        chicken_ram.address = chicken_address.q;
        chicken_ram.write_en = b1;
        chicken_ram.write_data = b000;
        
        chicken_address.d = chicken_address.q + MATRIX_WIDTH; //go to the next row
        chicken_counter.d = chicken_counter.q + 1;

        if (chicken_counter.q > 3){ //after 4 pixel skies generated
          chicken_counter.d = 0;
                    chicken_address.d =  MATRIX_WIDTH * current_chicken_column.q + 5;
          state.d = state.ERASECHICKEN4TOPLEFT;
        }
     
     state.ERASECHICKEN4TOPLEFT:
        chicken_ram.address = chicken_address.q;
        chicken_ram.write_en = b1;
        chicken_ram.write_data = b000;
        
        chicken_address.d = chicken_address.q + MATRIX_WIDTH; //go to the next row
        chicken_counter.d = chicken_counter.q + 1;

        if (chicken_counter.q > 3){ //after 4 pixel skies generated
          chicken_counter.d = 0;
                    chicken_address.d =  MATRIX_WIDTH * current_chicken_column.q + 6;
          state.d = state.ERASECHICKEN5TOPLEFT;
        }  
         
    state.ERASECHICKEN5TOPLEFT:
        chicken_ram.address = chicken_address.q;
        chicken_ram.write_en = b1;
        chicken_ram.write_data = b000;
        
        chicken_address.d = chicken_address.q + MATRIX_WIDTH; //go to the next row
        chicken_counter.d = chicken_counter.q + 1;

        if (chicken_counter.q > 3){ //after 4 pixel skies generated
          chicken_counter.d = 0;
          state.d = state.SHIFTLEFTMID;
        }  
           
      state.SHIFTLEFTMID:
        if(current_chicken_column.q == 0){
          current_chicken_column.d = 27;
          chicken_address.d = MATRIX_WIDTH * 27 + 2;
        }
        else{
          current_chicken_column.d = current_chicken_column.q - 1;
          chicken_address.d = MATRIX_WIDTH * (current_chicken_column.q - 1) + 2;
          
        }
        state.d = state.GEN1CHICKEN;
      
        
        
      state.SHIFTRIGHTCHICKENBEGIN:
  
        chicken_address.d = MATRIX_WIDTH * (current_chicken_column.q) + 2;
        state.d = state.ERASECHICKEN1TOP;
      
      
      state.ERASECHICKEN1TOP:
        chicken_ram.address = chicken_address.q;
        chicken_ram.write_en = b1;
        chicken_ram.write_data = b000;
        chicken_address.d = chicken_address.q + MATRIX_WIDTH; //go to the next row
          
        chicken_counter.d = chicken_counter.q + 1;
 
        if (chicken_counter.q > (SPRITE_SIZE-2)){ 
          chicken_counter.d = 0;
          chicken_address.d =  MATRIX_WIDTH * current_chicken_column.q + 3;
          state.d = state.ERASECHICKEN2TOP;
        }
      
      state.ERASECHICKEN2TOP:
        chicken_ram.address = chicken_address.q;
        chicken_ram.write_en = b1;
        chicken_ram.write_data = b000;
        chicken_address.d = chicken_address.q + MATRIX_WIDTH; //go to the next row

        
        chicken_counter.d = chicken_counter.q + 1;
       
        
        if (chicken_counter.q > (SPRITE_SIZE-2)){ //after 4 pixel skies generated
          chicken_counter.d = 0;
          chicken_address.d =  MATRIX_WIDTH * current_chicken_column.q + 4;

          state.d = state.ERASECHICKEN3TOP;
        }
      
        
      state.ERASECHICKEN3TOP:
        chicken_ram.address = chicken_address.q;
        chicken_ram.write_en = b1;
        chicken_ram.write_data = b000;
        chicken_address.d = chicken_address.q + MATRIX_WIDTH; //go to the next row

        
        chicken_counter.d = chicken_counter.q + 1;
       
        
        if (chicken_counter.q > (SPRITE_SIZE-2)){ //after 4 pixel skies generated
          chicken_counter.d = 0;
          chicken_address.d =  MATRIX_WIDTH * current_chicken_column.q + 5;

          state.d = state.ERASECHICKEN4TOP;
        }
      
     state.ERASECHICKEN4TOP:
        chicken_ram.address = chicken_address.q;
        chicken_ram.write_en = b1;
        chicken_ram.write_data = b000;
        chicken_address.d = chicken_address.q + MATRIX_WIDTH; //go to the next row

        
        chicken_counter.d = chicken_counter.q + 1;
       
        
        if (chicken_counter.q > (SPRITE_SIZE-2)){ //after 4 pixel skies generated
          chicken_counter.d = 0;
          chicken_address.d =  MATRIX_WIDTH * current_chicken_column.q + 6;

          state.d = state.ERASECHICKEN5TOP;
        }
        
      state.ERASECHICKEN5TOP:
        chicken_ram.address = chicken_address.q;
        chicken_ram.write_en = b1;
        chicken_ram.write_data = b000;
        chicken_address.d = chicken_address.q + MATRIX_WIDTH; //go to the next row

        
        chicken_counter.d = chicken_counter.q + 1;
       
        
        if (chicken_counter.q > (SPRITE_SIZE-2)){ //after 4 pixel skies generated
          chicken_counter.d = 0;
          state.d = state.SHIFTRIGHTMID;
        }  
        
      state.SHIFTRIGHTMID:
      if(current_chicken_column.q == 27){
          current_chicken_column.d = 0;
          chicken_address.d = 2;
        }
        
        else{
       current_chicken_column.d = current_chicken_column.q + 1;
       chicken_address.d = MATRIX_WIDTH * (current_chicken_column.q + 1) + 2;
          
        }
        state.d = state.GEN1CHICKEN;
      
        
        
      state.GEN1CHICKEN:
        chicken_ram.address = chicken_address.q;
        chicken_ram.write_en = b1;
        chicken_ram.write_data = SPRITE[0][chicken_counter.q];
        
        chicken_counter.d = chicken_counter.q + 1;
        chicken_address.d = chicken_address.q + MATRIX_WIDTH; //go to the next row
        
        if (chicken_counter.q > (SPRITE_SIZE-2)){ 
          chicken_counter.d = 0;
          chicken_address.d = MATRIX_WIDTH * (current_chicken_column.q) + 3; //reset to the beginning, but now the fourth from the bottom pixel
          state.d = state.GEN2CHICKEN;
        }
      
      state.GEN2CHICKEN:
        chicken_ram.address = chicken_address.q;
        chicken_ram.write_en = b1;
        chicken_ram.write_data = SPRITE[1][chicken_counter.q];
        
        chicken_counter.d = chicken_counter.q + 1;
        chicken_address.d = chicken_address.q + MATRIX_WIDTH; //go to the next row
        
        if (chicken_counter.q > (SPRITE_SIZE-2)){ 
          chicken_counter.d = 0;
           chicken_address.d = MATRIX_WIDTH * (current_chicken_column.q) + 4; //reset to the beginning, but now the fourth from the bottom pixel
          state.d = state.GEN3CHICKEN;
        }
      
      state.GEN3CHICKEN:
        chicken_ram.address = chicken_address.q;
        chicken_ram.write_en = b1;
        chicken_ram.write_data = SPRITE[2][chicken_counter.q];
        
        chicken_counter.d = chicken_counter.q + 1;
        chicken_address.d = chicken_address.q + MATRIX_WIDTH; //go to the next row
        
        if (chicken_counter.q > (SPRITE_SIZE-2)){ 
          chicken_counter.d = 0;
          chicken_address.d = MATRIX_WIDTH * (current_chicken_column.q) + 5; //reset to the beginning, but now the fourth from the bottom pixel
          state.d = state.GEN4CHICKEN;
        }
        
   
      state.GEN4CHICKEN:
        chicken_ram.address = chicken_address.q;
        chicken_ram.write_en = b1;
        chicken_ram.write_data = SPRITE[3][chicken_counter.q];
        
        chicken_counter.d = chicken_counter.q + 1;
        chicken_address.d = chicken_address.q + MATRIX_WIDTH; //go to the next row
        
        if (chicken_counter.q > (SPRITE_SIZE-2)){ 
          chicken_counter.d = 0;
          chicken_address.d = MATRIX_WIDTH * (current_chicken_column.q) + 6; //reset to the beginning, but now the fourth from the bottom pixel
          state.d = state.GEN5CHICKEN;
        }
      
        
        
        
        
        
      state.GEN5CHICKEN:
        chicken_ram.address = chicken_address.q;
        chicken_ram.write_en = b1;
        chicken_ram.write_data = SPRITE[4][chicken_counter.q];
        
        chicken_counter.d = chicken_counter.q + 1;
        chicken_address.d = chicken_address.q + MATRIX_WIDTH; //go to the next row
        
        if (chicken_counter.q > (SPRITE_SIZE-2)){ 
          chicken_counter.d = 0;
          state.d = state.CHECKCOLSTART;
        }
        
      
        
      
      state.GENERATESKYBEGIN:
        sky_counter.d = 0;
        sky_address.d = MATRIX_WIDTH * current_sky_column.q + MATRIX_WIDTH - 1; //starts at the  highest row, thats 63
        state.d = state.GENERATESKY1;
      

      state.GENERATESKY1:
        background_ram.address = sky_address.q;
        background_ram.write_en = b1;
        background_ram.write_data = b100;
        
        sky_counter.d = sky_counter.q + 1;
        sky_address.d = sky_address.q + MATRIX_WIDTH; //go to the next row
        
        if (sky_counter.q > 0){ //after 2 pixels skies generated
          sky_counter.d = 0;
          sky_address.d =  MATRIX_WIDTH * current_sky_column.q + MATRIX_WIDTH - 2;
          state.d = state.GENERATESKY2;
        }
      
      state.GENERATESKY2:
        background_ram.address = sky_address.q;
        background_ram.write_en = b1;
        background_ram.write_data = b100;
        
        sky_counter.d = sky_counter.q + 1;
        sky_address.d = sky_address.q + MATRIX_WIDTH; //go to the next row
        
        if (sky_counter.q > 0){ //after 4 pixel skies generated
          sky_counter.d = 0;
          sky_address.d =  MATRIX_WIDTH * current_sky_column.q + MATRIX_WIDTH - 3;
          state.d = state.LOOP;
        }
        
      

 

      
      state.CHECKCOLSTART:
        check_column_address.d = 5; //begin from address 7, top of the chicken head
        column_counter.d =0; //this will loop from 0 to 15
        //sky_address.d = MATRIX_WIDTH * (current_sky_column.q+1) + MATRIX_WIDTH - 3;
        state.d = state.CHECKCOLREAD;
      
      state.CHECKCOLREAD:
        chicken_ram.address = check_column_address.q;
        chicken_ram.address = check_column_address.q;
        background_ram.address = check_column_address.q;
        background_ram.address = check_column_address.q;
        column_counter.d= column_counter.q+1;
        //   counter1.d = 0;
        if (column_counter.q>30){
          column_counter.d = 0;
          state.d = state.LOOP; //finished, return to loop, no collision 
          }
        else{
        state.d = state.CHECKCOL1TOP;
        }
      
      state.CHECKCOL1TOP:
        bgexist =  |background_ram.read_data;
        chickexist = |chicken_ram.read_data;
        if((bgexist&chickexist)){// |(bottomchickenexist&bottomskyexist)){

          state.d = state.SKYWIN; //chickenloose 
        }else{
          check_column_address.d = check_column_address.q+MATRIX_WIDTH;
          state.d = state.CHECKCOLREAD; //loops back, read next column 
        }
        
   
      state.CLEARRAM:
        
        if (clearReg.q < RAMSIZE-1){
          background_ram.address = clearReg.q;
          background_ram.write_en = 1;
          background_ram.write_data = b000;
          

          chicken_ram.address = clearReg.q;
          chicken_ram.write_en = 1;
          chicken_ram.write_data = b000;
          
          chicken_ram.address = clearReg.q;
          chicken_ram.write_en = 1;
          chicken_ram.write_data = b000;
          
          clearReg.d = clearReg.q + 1;
        }
        else{
          clearReg.d = 0;
          state.d = state.START;
          
        }
        
        
      state.SKYWIN:
        background_ram.address = 0;
        background_ram.write_en = b1;
        background_ram.write_data = b001;
        restart.d = 1;
        state.d = state.LOOP;  
        
      state.LOOP:
  

        if(start_fromfsm && restart.q == 1){
          state.d = state.CLEARRAM;
         }
        
        else if (restart.q == 0){
          if (genSky){

              current_sky_column.d = generateSky;
              state.d = state.GENERATESKYBEGIN;

          } 
          
          else if(shiftSky){
            shift_address.d = 0;
            state.d = state.SHIFTDOWNADDRESS;
          }
        
          else if(shiftchickenleft){
            shiftChickenWhich.d = 0;
            state.d = state.SHIFTLEFTCHICKENBEGIN;
          }
          
          else if(shiftchickenright){
            shiftChickenWhich.d = 0;
            state.d = state.SHIFTRIGHTCHICKENBEGIN;
          }
        }
        
        

        background_ram.address = (row_address * MATRIX_WIDTH) + column_address;
        chicken_ram.address = (row_address * MATRIX_WIDTH) + column_address;
        
       // out = c{3b111, 3b011};
       if (chicken_ram.read_data){
          out = c{3b110, chicken_ram.read_data};
        }
        
        else{
          out = c{3b011, background_ram.read_data};
         }

      
      
    }

    
  }
}